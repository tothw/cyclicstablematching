\documentclass[letterpaper,12pt,oneside,onecolumn]{article}
\usepackage[margin=1in, bottom=1in, top=1in]{geometry} %1 inch margins
\usepackage{amsmath, amssymb, amstext}
\usepackage{fancyhdr}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

%Macros
\newcommand{\A}{\mathbb{A}} \newcommand{\C}{\mathbb{C}}
\newcommand{\D}{\mathbb{D}} \newcommand{\F}{\mathbb{F}}
\newcommand{\N}{\mathbb{N}} \newcommand{\R}{\mathbb{R}}
\newcommand{\T}{\mathbb{T}} \newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
 
 
\newcommand{\cA}{\mathcal{A}} \newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}} \newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{\mathcal{E}} \newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}} \newcommand{\cH}{\mathcal{H}}
\newcommand{\cI}{\mathcal{I}} \newcommand{\cJ}{\mathcal{J}}
\newcommand{\cK}{\mathcal{K}} \newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}} \newcommand{\cN}{\mathcal{N}}
\newcommand{\cO}{\mathcal{O}} \newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}} \newcommand{\cR}{\mathcal{R}}
\newcommand{\cS}{\mathcal{S}} \newcommand{\cT}{\mathcal{T}}
\newcommand{\cU}{\mathcal{U}} \newcommand{\cV}{\mathcal{V}}
\newcommand{\cW}{\mathcal{W}} \newcommand{\cX}{\mathcal{X}}
\newcommand{\cY}{\mathcal{Y}} \newcommand{\cZ}{\mathcal{Z}}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
%Page style
\pagestyle{fancy}

\listfiles

\raggedbottom

\rhead{William Justin Toth Cyclic Stable Matching Enumeration} %CHANGE n to ASSIGNMENT NUMBER ijk TO COURSE CODE
\renewcommand{\headrulewidth}{1pt} %heading underlined
%\renewcommand{\baselinestretch}{1.2} % 1.2 line spacing for legibility (optional)

\begin{document}
\section{Introduction}
\paragraph{}
In the cyclic stable matching problem we are given three sets $A$, $B$, and $C$ of equal size $n$. The elements of $A$ each maintain a total preference order over the elements of $B$ which we will denote by $<_a$ for each $a \in A$. Similarly elements of $B$ maintain a total preference order over elements of $C$ and elements of $C$ maintain a total preference order over elements of $A$. We define a matching $M$ to be a set of the form
$$\{ \{a,b,c\}: a \in A, b \in B, c\in C\}$$
satisfying 
$$|\{ \{a,b,c\} \in M : v \in \{a,b,c\}\}| \leq 1$$
for all $v \in A \cup B \cup C$. For each $a \in A$ we define $M(a) = b$ such that $\{a,b,c\} \in M$ for some $c$, and $M(a) = 0$ ($0$ is simply some empty element) if no such $b$ exists. We define $M(b)$ for $b \in B$ and $M(c)$ for $c \in C$ analogously. By the definition of $M$ it is clear that these are well defined.
\paragraph{}
We call a matching stable if there does not exist a triple $(a,b,c) \in A \times B \times C$ such that 
$$ b >_a M(a) \quad\text{and}\quad c >_b M(b) \quad\text{and}\quad a>_c M(c).$$
Herein we adopt the convention that any element is preferable to $0$ in any ordering. It is conjectured  by Knuth that a stable matching exists for any instance of the cyclic stable matching problem. It is known that this result holds for $n \leq 4$. We propose a computational search strategy to decide if the conjecture holds for higher $n$, say $n=5$.
\section{General Strategy}
\paragraph{}
The goal of the computational search is essentially smart brute force. We aim to test all instances of the problem (which we will refer to as Preference Systems) for $n=5$. Brief calculations can show that simply enumerating all Preference Systems would be infeasible, so we have devised a strategy to reduce the number of systems we need to check. The idea stems from the fact that if we relax the total orders to partial orders and if we can find a stable perefect matching $M$ on a partial ordered preference system then any total order instance that arise by extending the partial order (appending unordered agents to end of preference lists) has $M$ as a stable matching. 
\paragraph{}
Another idea we use is to develop sufficient conditions that tell us if a system will have a stable matching without actually finding it For instance if there is a $3$-cycle of first choice preferences, then we have a stable matching by induction.
\paragraph{}
We also observe that there is inherent symmetry in the problem instances. If one instance can be obtained from another by permuting the roles of sets $A,B,C$ then clearly if one has a Stable matching the other does (by permuting the $A$,$B$,$C$ entries of the matching). Another symmetry comes from relabelling within a set $A, B, C$. If you have a problem instance $A,B,C$ and you have a bijection
$$\phi: A \rightarrow A.$$
Then for all $c \in C$ define the total order $>_c^\phi$ to be
$$\{(\phi(a_1),\phi(a_2)) : a_1 >_c a_2 \}.$$
If the bijection $\phi$ satisfies
$$a_1 >_c a_2 \implies \phi(a_1) >^\phi_c \phi(a_2)$$
for all $c \in C$, then the problem instances given by $A,B,C$ with original orders and $\phi(A), B, C$ with each $c\in C$ using order $>_c^\phi$ are symmetric in the sense that a stable matching for one implies a stable matching for the other (and finding second stable matching is given through applying $\phi$ to first stable matching). $\textit{Note: It is still unclear how to test and remove all symmetry effectively}$.
\paragraph{}
Our general algorithm is a depth search working as follows (we will explain preference system nodes below) algorithm:
\begin{enumerate}
\item Initialize a preference system of size $n=5$ with empty partial orders
\item Create a preference system node $PSNode$ and have it store the empty preference system.
\item While $PSNode$ has next:
\begin{enumerate}
\item Let $PSNode$ be $PSNode.next()$. Let $P$ be preference system of $PSNode$.
\item Test if $P$ is satisfies a sufficient condition for stable matching.
\item If so set $PSNode$ to $PSNode.parent()$.
\item If not and $P$ is a complete preference system (all orders are complete) then you have found a counterexample
\end{enumerate}
\item If all nodes are exhausted, and no counterexample is found, then conjecture holds for $n=5$.
\section{Preference System Nodes}
\paragraph{}
Preference System Nodes are a data structure that contains the data necessary to work through our depth first search. We think of preference systems which need to be searched as being in a tree structure which we will depth first search for a counterexample.
\paragraph{}
A Preference System Node stores a few things: the preference system of partial ordered preferences which is to be checked at this node, the parent Preference System Node that this node descends from, and the children Nodes which are to be explored after this node.
\paragraph{}
The $parent()$ method returns the parent Preference System Node. The $next()$ method is slightly more nuanced. It returns an unexplored child of $PSNode$ if one exists and it returns the parent node otherwise. The children of a $PSNode$ are defined based on an extender agent. Consider the preference system data in $PSNode$. The extender agent is the agen in the preference system with the shortest preference list of acceptable matches, subject to that it has the lowest group number index, and subject to that it has the lowest agent number index (thus it is unique). For each unacceptable match for $PSNode$'s extender agent, there is a child of $PSNode$ where that unacceptable match is appended as the lowest ranked acceptable match of extender agent. 
\paragraph{}
Note that in the current implementation we reduce symmetry by eliminating child nodes that are not lexicographically (when all partial preference orders are appended as a string) minimal. These checks are in a state of change at present.
\section{Sufficient Checks and Stability}
\paragraph{}
We use the following sufficient conditions to decide if a preference system has a Stable Matching before enumerating possible matchings:
\begin{itemize}
\item Existence of a set $V \in \{A,B,C\}$ where each agent in $V$ has the same first choice.
\item Existence of a set $V \in \{A,B,C\}$ where each agent in $V$ has a different first choice.
\item Existence of a triple $(a,b,c) \in A\times B\times C$ where $b$ is first choice of $a$, $c$ is first choice of $b$, and $a$ is first choice of $c$. We call this a first choice $3$-cycle.
\item Existence of a first choice $9$-cycle.
\end{itemize}
\paragraph{}
These conditions have been generalized in a check for a sufficient matching as: if we can find a stable partial matching wherein each matched agent has all agents they prefer to their partner matched then we can remove the matched vertices and complete the stable matching by induction. We check for such stable partial matchings in our implementation if none of the above sufficient conditions (which are faster to check as special cases) hold.
\end{document}
